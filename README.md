# Pymod

Auto-generate a [Python](http://www.python.org) module to wrap the procs in
a [Nim programming language](http://nim-lang.org) module.

The **Pymod** software package consists of Nim bindings & Python scripts to
automate the generation of
[Python C-API extension module](https://docs.python.org/2/extending/index.html)
boilerplate for Nim procs.
After Pymod has been run, there will be an auto-generated, auto-compiled
Python module that exposes the Nim procs in Python.

The auto-generated C-API boilerplate code handles the parsing & type-checking
of the function arguments passed from Python, including correct handling of Python
ref-counts if a type error occurs or an exception is raised.  The boilerplate
code also translates Nim exceptions (including back-traces) to Python exceptions.
Finally, the boilerplate code provides auto-generated Python docstrings that
have been extracted from the Nim procs.

There's even a type (`PyArrayObject`) that provides a Nim interface to
[Numpy arrays](http://www.scipy-lectures.org/intro/numpy/array_object.html),
so you can pass Numpy arrays into your Nim procs and access them natively.

Pymod is definitely still in the **alpha** phase of software maturity, and it's
far from feature-complete, but it's been usable for our work for about 9 months now
(and we've been using it regularly during that time).  There's a lot of hacky code
in there, but it gets the job done.

Motivation
----------

Perhaps you have a large body of existing Python code, that you can't or
don't want to rewrite.  Perhaps you want to use [Numpy](http://www.numpy.org/),
[Scipy](http://www.scipy.org/) or [Matplotlib](http://www.matplotlib.org).
Perhaps your program's main loop simply must be in Python.

However, you would prefer to write Nim code and then call your Nim procs
from the Python code.  (There are many more systems written in Python than
in Nim, but it would be great to start extending them in Nim!)
You can write
[Python C-API extension modules](https://docs.python.org/2/extending/extending.html)
to wrap your Nim procs, but all the
[C-API boilerplate](https://docs.python.org/2/c-api/)
is a huge drag, especially if you check types and manage reference counts
and handle Nim exceptions properly.

That's what Pymod is for.

Usage
-----

Using Pymod is a 4-step process, preceded by an optional zeroth step:

1. At the top of your Nim source code module, import the module `pymod`.
   You might additionally wish to import `pymodpkg/docstrings` (to enable
   Python-like docstrings) and/or `pymodpkg/pyarrayobject` (to enable the
   `PyArrayObject` type that corresponds to Numpy's array type).
2. In your Nim source code module, annotate each Nim proc to be exported
   with the `{.exportpy.}` pragma (named by analogy with the standard Nim
   `{.exportc.}` pragma).
3. At the end of your Nim source code model, configure the Python module using
   the `initPyModule()` macro, specifying the desired module name as a string
   (without a filename suffix), followed by the names of the Nim procs that
   should be compiled into the Python module.
4. Invoke the supplied Python script `pmgen.py` with the filename of your
   Nim source code module as a command-line argument, to auto-generate &
   invoke a set of Makefiles that will in turn initiate & run the Pymod process.

When the script `pmgen.py` is run, it will create a subdirectory `pmgen` in
the current directory.  All the source code generated by Pymod will be placed
into this subdirectory and compiled.  At the end of the compilation process,
the new Python module, a shared object file, will be moved back into the
current directory.

The optional zeroth step is to define your own `PyObject` type (similar to how
Pymod defines the `PyArrayObject` type to represent Numpy's array type)
in Pymod's type-mapping registry, using the `definePyObjectType()` macro.
This provides Pymod with a mapping from an already-defined Nim type to the
corresponding Python & C-API types, enabling Pymod to generate the type-checking
boilerplate for additional non-core-Python types.

Example
-------

Here's a short "Hello world" example (assumed to be in a file called `greeting.nim`):

    ## Compile this Nim module using the following command:
    ##   python path/to/pmgen.py greeting.nim

    import strutils  # `%` operator

    import pymod
    import pymodpkg/docstrings

    proc greet*(audience: string): string {.exportpy.} =
      docstring"""Greet the specified audience with a familiar greeting.

      The string returned will be a greeting directed specifically at that audience.
      """
      return "Hello, $1!" % audience

    initPyModule("hw", greet)

Use the Python script `pmgen.py` to auto-generate & compile the boilerplate code:

    python path/to/pmgen.py greeting.nim

There will now be a compiled Python extension module `hw.so` in the current directory.
(It is called `hw` because is the name that was specified in the `initPyModule()` macro).

In a Python interpreter, you can import the module and invoke the `greet` function:

    >>> import hw
    >>> hw.greet
    <built-in function greet>
    >>> hw.greet("World")
    'Hello, World!'
    >>>

You can also invoke the built-in Python interpreter `help` function about the `greet` function:

    >>> help(hw.greet)
    Help on built-in function greet in module hw:

    greet(...)
        greet(audience: str) -> (str)

        Parameters
        ----------
        audience : str -> string

        Returns
        -------
        out : (str) <- (string)

        Greet the specified audience with a familiar greeting.

        The string returned will be a greeting directed specifically at that audience.

There is additional example code in the `tests` directory.

System requirements
-------------------

* The [latest Nim compiler from Github](http://nim-lang.org/download.html#installation-from-github)
  * either the `stable` or `devel` branches
  * but **not the recent [Nim 0.12.0 release](http://nim-lang.org/news.html#Z2015-10-27-version-0-12-0-released)**. :(
* CPython 2.7 or CPython 3.2+
* Python C development header files & static library
* [Numpy](http://www.numpy.org)
* Numpy C development header files
* A C compiler [for use by Nim](http://nim-lang.org/download.html)

Per-project configuration
-------------------------

If there is a file `pymod.cfg` in the same directory as the Nim module you want
to wrap, Pymod will read this as a configuration file for that project.

By default, Pymod runs the Nim compiler in **non-release** mode, and additionally
performs per-dereference bounds-checking of the `PyArrayObject` iterators.
This is safe (and catches all sorts of pesky bugs!) but slow.

If the file `pymod.cfg` in the current directory contains the following directives:

    [all]
    nimSetIsRelease: true

then the Nim compiler will be invoked in **release mode**, and bounds-checking
of the `PyArrayObject` iterators will be switched off.  Your code will now run
much faster!

Docstrings
----------

Pymod will also auto-generate a Python docstring for each function in the
extension module, specifying the function's parameter types & return type,
based upon the parameter types & return types of the exported Nim proc.
You can embed additional documentation in each Nim proc you want to export,
using the supplied `docstring"""Text goes here."""` string type.  Any docstrings
in the proc will be extracted automatically and included in the generated Python
docstring.  There is an example of docstring usage in the code sample above.

Procedure parameter & return types
----------------------------------

Procedure parameters may be basic types (`int`, `int{64,32,16,8}`, `uint`,
`uint{64,32,16,8}`, `float`, `float{64,32}` or `string`) or `ptr PyArrayObject`.
Default parameters are supported to a limited extent, although the parameter
type must be specified explicitly, and is currently restricted to the `string`,
integer & floating-point types.

Procedure return values may be basic types (`int`, `int{64,32,16,8}`, `uint`,
`uint{64,32,16,8}`, `float`, `float{64,32}` or `string`), `ptr PyArrayObject` or
a Nim tuple of any of these types.  Nested tuples are currently not supported.
By default, named tuples in Nim are returned as raw tuples to Python:

    # Nim                   # Python
    tuple[ a, b: int ]  =>  (a_value, b_value)

If `exportpy` is specified as `exportpy return_dict` then the generated
code will instead return a Python dict containing the named properties:

    # Nim                   # Python
    tuple[ a, b: int ]  =>  { "a": a_value, "b": b_value }

PyArrayObject type
------------------

Pymod provides the `PyArrayObject` type to allow Python code to pass
[Numpy ndarrays](http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html)
into Nim procs with appropriate type-safety.  To access the `PyArrayObject`
Nim type definition, import `pymodpkg/pyarrayobject` in your Nim module (after
you have already imported `pymod`).

Because the Numpy array object was allocated in Python, the type of the Nim
proc parameter or return value is `ptr PyArrayObject`.  **Note** that it is a
Nim `ptr` not a Nim `ref`.  Your code should pass around `ptr PyArrayObject`.

Pymod also wraps many C functions from the
[Numpy C-API](http://docs.scipy.org/doc/numpy/reference/c-api.html)
for Numpy array manipulation & attribute access.
To review the full list of `PyArrayObject` procs that Pymod provides, browse
the Pymod source file `pymodpkg/pyarrayobject.nim`.  To get you started,
here is a very incomplete selection of the Numpy array attributes that Pymod offers:
`arr.data`, `arr.nd`, `arr.dimensions`, `arr.shape`, `arr.strides`, `arr.descr`,
`arr.dtype`.

**Note** that, due to its Pythonic origin, `ptr PyArrayObject` is not a
Nim generic type.  So the element data-type of a `ptr PyArrayObject` instance
is unknown to Nim.  The preferred method of accessing the (appropriately-typed)
elements of a `ptr PyArrayObject` instance is to use one of the two supplied
`PyArrayIterator` types:

* `PyArrayForwardIterator[T]` (returned by `arr.iterateForward(T)`)
* `PyArrayRandomAccessIterator[T]` (returned by `arr.accessFlat(T)`)

Both of the `PyArrayIterator` types offer **1-D** iteration & indexing over
a "flat" interpretation of the Numpy array data.  These two iterator types
are inspired by the [C++ iterator category model](http://www.cplusplus.com/reference/iterator/).
By default, the iterators implement per-dereference bounds-checking.
This bounds-checking can be disabled, as described above in the section
_Per-project configuration_.

**Note** that the `PyArrayIterator` types can't handle any of the following
usage scenarios:

 * non-C-contiguous array memory
 * strides
 * multi-dimensional indexing

PyArrayObject & PyArrayIterator usage example
---------------------------------------------

Here is a simple example of how to use `PyArrayObject` & `PyArrayForwardIterator[T]`:

    import strutils  # `%`
    import pymod
    import pymodpkg/pyarrayobject

    proc addOne*(arr: ptr PyArrayObject) {.exportpy} =
      let dt = arr.dtype
      echo "PyArrayObject has shape $1 and dtype $2" % [$arr.shape, $dt]
      if dt == np_int32:
        let bounds = arr.getBounds(int32)  # Iterator bounds
        var iter = arr.iterateForward(int32)  # Forward iterator
        while iter in bounds:
          iter[] += 1
          inc(iter)
      else:
        let msg = "expected input array of dtype $1, received dtype $2" % [$np_int32, $dt]
        raise newException(ValueError, msg)

    initPyModule("_myModule", addOne)

You can test the Pymod-wrapped Nim proc `addOne` using a Python script like this:

    import numpy as np
    import _myModule as mm

    a = np.arange(10, dtype=np.int32).reshape((2, 5))
    print(a)
    mm.addOne(a)
    print(a)

    print("")

    b = np.arange(10, dtype=np.float32).reshape((2, 5))
    print(b)
    mm.addOne(b)  # Uh-oh!  ValueError will be raised here!
    print(b)

The output from running this script will look something like this:

    [[0 1 2 3 4]
     [5 6 7 8 9]]
    PyArrayObject has shape @[2, 5] and dtype numpy.int32
    [[ 1  2  3  4  5]
     [ 6  7  8  9 10]]

    [[ 0.  1.  2.  3.  4.]
     [ 5.  6.  7.  8.  9.]]
    PyArrayObject has shape @[2, 5] and dtype numpy.float32
    Traceback (most recent call last):
      File "test_arr1.py", line 13, in <module>
        mm.addOne(b)  # Uh-oh!  ValueError will be raised here!
    ValueError: expected input array of dtype numpy.int32, received dtype numpy.float32
    Nim traceback (most recent call last):
      File "pmgen_myModule_wrap.nim", line 26, in exportpy_addOne
      File "arr1.nim", line 16, in addOne


Tips, warnings & gotchas
------------------------

Here are some helpful hints about a few sharp edges of Pymod (mostly due to
sharp edges in Nim that we haven't been able to cover over completely) that
can trip you up (and then confuse you with obscure compiler error messages):

* If you want to `exportpy` a proc using Pymod, **don't** give your proc the
  same name as the Nim module that contains the proc (or in fact, the same name
  as any other procs in that same module).
* If you want to `exportpy` a proc using Pymod, ensure that the proc is also
  [exported in Nim](http://nim-lang.org/docs/manual.html#procedures-export-marker)
  by marking it with an asterisk after the proc-name.

What about calling Python from Nim?
-----------------------------------

Pymod enables you to wrap your Nim procs so they can be called from Python.

If instead you want to call Python functions (maybe even the interpreter)
from Nim (ie, the control flows in the opposite direction), Pymod is not
what you're looking for.

In a situation like this, [python.nim](https://github.com/nim-lang/python)
or the [NimBorg project](https://github.com/micklat/NimBorg) might be what
you're looking for.

Implementation details
----------------------

We want to make existing Python types (and extended types like
[Numpy arrays](https://scipy-lectures.github.io/intro/numpy/array_object.html))
available in Nim procs.  The idea is that objects of these Python types will
be created in the existing Python code, then passed through to Nim procs for
processing, and then the results will be returned to the Python code for the
pre-existing processing or viewing in Python.

For this reason, we decided not to use the
[Python ctypes module](https://docs.python.org/2/library/ctypes.html);
the focus of `ctypes` seems to be on propagating types in the opposite
direction.  Instead of making fully-fledged Python types easily available
in C, `ctypes` wraps lowest-common-denominator C types and structs for
basic access in Python.

The way
[ctypes handles pointers](https://docs.python.org/2/library/ctypes.html#pointers)
& [structs](https://docs.python.org/2/library/ctypes.html#structures-and-unions)
requires you to build your object types up in terms of C primitive types,
so they can be accessed as method-less, field-only objects in Python.
But the Python types we want to use in Nim are already defined in Python!
So `ctypes` would be more applicable to us if we wanted to make existing
Nim data-structures available in Python, rather than the other way around.

In the future, we might investigate the use of
[CFFI](http://cffi.readthedocs.org/en/release-0.8/) &
[cffiwrap](http://cffiwrap.readthedocs.org/en/latest/).
These look (at a first, superficial glance) like they might be more
Python-type-friendly than `ctypes`.

