# Pymod

Auto-generate a [Python](http://www.python.org) module to wrap the procs in
a [Nim programming language](http://nim-lang.org) module.

The **Pymod** software package consists of Nim bindings & Python scripts to
automate the generation of
[Python C-API extension module](https://docs.python.org/2/extending/index.html)
boilerplate for Nim procs.
After Pymod has been run, there will be an auto-generated, auto-compiled
Python module that exposes the Nim procs in Python.

The auto-generated C-API boilerplate code handles the parsing & type-checking
of the function arguments passed from Python, including correct handling of Python
ref-counts if a type error occurs or an exception is raised.  The boilerplate
code also translates Nim exceptions (including back-traces) to Python exceptions.
Finally, the boilerplate code provides auto-generated Python docstrings that
have been extracted from the Nim procs.

There's even a type (`PyArrayObject`) that provides a Nim interface to
[Numpy arrays](http://www.scipy-lectures.org/intro/numpy/array_object.html),
so you can pass Numpy arrays into your Nim procs and access them natively.

Pymod is definitely still in the **alpha** phase of software maturity, and it's
far from feature-complete, but it's been usable for our work for about 9 months now
(and we've been using it regularly during that time).  There's a lot of hacky code
in there, but it gets the job done.

Motivation
----------

Perhaps you have a large body of existing Python code, that you can't or
don't want to rewrite.  Perhaps you want to use [Numpy](http://www.numpy.org/),
[Scipy](http://www.scipy.org/) or [Matplotlib](http://www.matplotlib.org).
Perhaps your program's main loop simply must be in Python.

However, you would prefer to write Nim code and then call your Nim procs
from the Python code.  (There are many more systems written in Python than
in Nim, but it would be great to start extending them in Nim!)
You can write
[Python C-API extension modules](https://docs.python.org/2/extending/extending.html)
to wrap your Nim procs, but all the
[C-API boilerplate](https://docs.python.org/2/c-api/)
is a huge drag, especially if you check types and manage reference counts
and handle Nim exceptions properly.

That's what Pymod is for.

Usage
-----

Using Pymod is a 4-step process, preceded by an optional zeroth step:

1. At the top of your Nim source code module, import the module `pymod`.
  * **Tip:** You might additionally wish to import `pymodpkg/docstrings` (to
    enable Python-like docstrings) and/or `pymodpkg/pyarrayobject` (to enable
    the `PyArrayObject` type that corresponds to Numpy's array type).
2. In your Nim source code module, annotate each Nim proc to be exported
   with the `{.exportpy.}` pragma (named by analogy with the standard Nim
   `{.exportc.}` pragma).
3. At the end of your Nim source code model, configure the Python module using
   the `initPyModule()` macro, specifying the desired Python module name as a
   string (without a filename suffix), followed by the names of the Nim procs
   that should be compiled into the Python module.
  * **Tip:** You can use the `initPyModule()` macro multiple times at the end
    of your Nim module, with different Python module names & different
    combinations of Nim procs, to create multiple Python modules.
4. Invoke the supplied Python script `pmgen.py` with the filename of your
   Nim source code module as a command-line argument, to auto-generate &
   invoke a set of Makefiles that will in turn initiate & run the Pymod process.

When the script `pmgen.py` is run, it will create a subdirectory `pmgen` in
the current directory.  All the source code generated by Pymod will be placed
into this subdirectory and compiled.  At the end of the compilation process,
the new Python module, a shared object file, will be moved back into the
current directory.

The optional zeroth step is to define your own `PyObject` type (similar to how
Pymod defines the `PyArrayObject` type to represent Numpy's array type)
in Pymod's type-mapping registry, using the `definePyObjectType()` macro.
This provides Pymod with a mapping from an already-defined Nim type to the
corresponding Python & C-API types, enabling Pymod to generate the type-checking
boilerplate for additional non-core-Python types.

**Note** that the `{.exportpy.}` pragma & `initPyModule()` macro are
**inert by default** (that is, they have no effect), so you can add them to
existing Nim code without breaking that Nim code.  It's only when you run
the script `pmgen.py` (which, among other actions, supplies the switch
`--define:pmgen` to the Nim compiler) that the `{.exportpy.}` pragma &
`initPyModule()` macro are activated.

Example
-------

Here's a short "Hello world" example (assumed to be in a file called `greeting.nim`):

    ## Compile this Nim module using the following command:
    ##   python path/to/pmgen.py greeting.nim

    import strutils  # `%` operator

    import pymod
    import pymodpkg/docstrings

    proc greet*(audience: string): string {.exportpy.} =
      docstring"""Greet the specified audience with a familiar greeting.

      The string returned will be a greeting directed specifically at that audience.
      """
      return "Hello, $1!" % audience

    initPyModule("hw", greet)

Use the Python script `pmgen.py` to auto-generate & compile the boilerplate code:

    python path/to/pmgen.py greeting.nim

There will now be a compiled Python extension module `hw.so` in the current directory.
(It is called `hw` because that is the name that was specified in the `initPyModule()` macro).

In a Python interpreter, you can import the module and invoke the `greet` function:

    >>> import hw
    >>> hw.greet
    <built-in function greet>
    >>> hw.greet("World")
    'Hello, World!'
    >>>

You can also invoke the built-in Python interpreter `help` function about the `greet` function:

    >>> help(hw.greet)
    Help on built-in function greet in module hw:

    greet(...)
        greet(audience: str) -> (str)

        Parameters
        ----------
        audience : str -> string

        Returns
        -------
        out : (str) <- (string)

        Greet the specified audience with a familiar greeting.

        The string returned will be a greeting directed specifically at that audience.

There is additional example code in the `examples` directory.

System requirements
-------------------

* The [latest Nim compiler from Github](http://nim-lang.org/download.html#installation-from-github)
  * either the `master` or `devel` branches
  * but **not the recent [Nim 0.12.0 release](http://nim-lang.org/news.html#Z2015-10-27-version-0-12-0-released)**. :(
  * (A [suggested fix for this Nim 0.12.0 packaging problem](http://forum.nim-lang.org/t/1797/2#11256)
    has been proposed on the Nim forums.)
* CPython 2.7 or CPython 3.2+
* Python C development header files & static library
* [Numpy](http://www.numpy.org)
* Numpy C development header files
* [Make](https://en.wikipedia.org/wiki/Make_%28software%29)
* a C compiler [for use by Nim](http://nim-lang.org/download.html)

Per-project configuration
-------------------------

If there is a file `pymod.cfg` in the same directory as the Nim module you want
to wrap, Pymod will read this as a configuration file for that project.

By default, Pymod runs the Nim compiler in **non-release** mode, and additionally
performs per-dereference bounds-checking of the `PyArrayObject` iterators.
This is safe (and catches all sorts of pesky bugs!) but slow.

If the file `pymod.cfg` in the current directory contains the following directives:

    [all]
    nimSetIsRelease: true

then the Nim compiler will be invoked in **release mode**, and bounds-checking
of the `PyArrayObject` iterators will be switched off.  Your code will now run
much faster!

Docstrings
----------

Pymod will also auto-generate a Python docstring for each function in the
extension module, specifying the function's parameter types & return type,
based upon the parameter types & return types of the exported Nim proc.
You can embed additional documentation in each Nim proc you want to export,
using the supplied `docstring"""Text goes here."""` string type.  Any docstrings
in the proc will be extracted automatically and included in the generated Python
docstring.  There is an example of docstring usage in the code sample above.

Procedure parameter & return types
----------------------------------

Procedure parameters may be basic types (`int`, `int{64,32,16,8}`, `uint`,
`uint{64,32,16,8}`, `float`, `float{64,32}` or `string`) or `ptr PyArrayObject`.
Default parameters are supported to a limited extent, although the parameter
type must be specified explicitly, and is currently restricted to the `string`,
integer & floating-point types.

Procedure return values may be basic types (`int`, `int{64,32,16,8}`, `uint`,
`uint{64,32,16,8}`, `float`, `float{64,32}` or `string`), `ptr PyArrayObject` or
a Nim tuple of any of these types.  Nested tuples are currently not supported.
By default, named tuples in Nim are returned as raw tuples to Python:

    # Nim                   # Python
    tuple[ a, b: int ]  =>  (a_value, b_value)

If `exportpy` is specified as `exportpy return_dict` then the generated
code will instead return a Python dict containing the named properties:

    # Nim                   # Python
    tuple[ a, b: int ]  =>  { "a": a_value, "b": b_value }

PyArrayObject type
------------------

Pymod provides the `PyArrayObject` type to allow Python code to pass
[Numpy ndarrays](http://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html)
into Nim procs with appropriate type-safety.  To access the `PyArrayObject`
Nim type definition, import `pymodpkg/pyarrayobject` in your Nim module (after
you have already imported `pymod`).

Because the Numpy array object was allocated in Python, the type of the Nim
proc parameter or return value is `ptr PyArrayObject`.  **Note** that it is a
Nim `ptr`, not a Nim `ref`.  Your code should pass around `ptr PyArrayObject`.

Pymod also wraps many C functions from the
[Numpy C-API](http://docs.scipy.org/doc/numpy/reference/c-api.html)
for Numpy array manipulation & attribute access.
To review the full list of `PyArrayObject` procs that Pymod provides, browse
the Pymod source file `pymodpkg/pyarrayobject.nim`.

Here are some of the Numpy array attributes that Pymod exposes:

* `.data` (returns `pointer`)
* `.data(T)` (returns `ptr T`)
* `.descr`
* `.dimensions`
* `.dtype`
* `.nd`
* `.ndim` (an alias for `.nd`)
* `.shape` (an alias for `.dimensions`)
* `.strides`

Here are some of the Numpy functions for array creation & manipulation that Pymod wraps:

* `createSimpleNew(dims, npType)`
* `createNewCopyNewData(oldArray, order)`
* `copy(oldArray)`  (an alias for `createNewCopyNewData`)
* `createAsTypeNewData(oldArray, newType)`
* `doCopyInto(destArray, srcArray)`
* `doFILLWBYTE(destArray, val)`
* `doResizeDataInplace(oldArray, newShape, doRefCheck)`

**Note** that, due to its typeless Pythonic origin, `PyArrayObject` is not a
Nim generic type.  So the element data-type of a `PyArrayObject` instance
is unknown to Nim.  The Nim code must **specify the correct element data-type**
for the `PyArrayObject` elements.  The preferred method of accessing the
(appropriately-typed) elements of a `PyArrayObject` instance is to use one of
the two supplied `PyArrayIterator` types:

* `PyArrayForwardIterator[T]`
  * returned by `.iterateForward(T)`
  * can only be incremented & dereferenced
* `PyArrayRandomAccessIterator[T]`
  * returned by `.accessFlat(T)`
  * can be incremented, decremented, added, subtracted, dereferenced, indexed by any integer

Both of the `PyArrayIterator` types offer **1-D iteration & indexing** over
a "flat" interpretation of the Numpy array data.  These two iterator types
are inspired by the [C++ iterator category model](http://www.cplusplus.com/reference/iterator/).
By default, the iterators implement per-dereference bounds-checking.
This bounds-checking can be disabled, as described above in the section
_Per-project configuration_.

**Note** that the `PyArrayIterator` types can't handle any of the following
usage scenarios:

 * non-C-contiguous array memory
 * strides
 * multi-dimensional indexing

PyArrayObject & PyArrayIterator usage example
---------------------------------------------

Here is a simple example of how to use `PyArrayObject` & `PyArrayForwardIterator[T]`:

    import strutils  # `%`
    import pymod
    import pymodpkg/docstrings
    import pymodpkg/pyarrayobject

    proc addVal*(arr: ptr PyArrayObject, val: int32) {.exportpy} =
      docstring"""Add `val` to each element in the supplied Numpy array.

      The array is assumed to have dtype `int32`; otherwise, a ValueError will be
      raised.  The elements in the array will be modified in-place.
      """
      let dt = arr.dtype
      echo "PyArrayObject has shape $1 and dtype $2" % [$arr.shape, $dt]
      if dt == np_int32:
        let bounds = arr.getBounds(int32)  # Iterator bounds
        var iter = arr.iterateForward(int32)  # Forward iterator
        while iter in bounds:
          iter[] += val
          inc(iter)  # Increment the iterator manually.
      else:
        let msg = "expected array of dtype $1, received dtype $2" % [$np_int32, $dt]
        raise newException(ValueError, msg)

    initPyModule("_myModule", addVal)

You can test the Pymod-wrapped Nim proc `addVal` using a Python script like this:

    import numpy as np
    import _myModule as mm

    a = np.arange(10, dtype=np.int32).reshape((2, 5))
    print(a)
    mm.addval(a, 101)
    print(a)

    print("")

    b = np.arange(10, dtype=np.float32).reshape((2, 5))
    print(b)
    mm.addVal(b, 101)  # Uh-oh!  ValueError will be raised here!
    print(b)

The output from running this script will look something like this:

    [[0 1 2 3 4]
     [5 6 7 8 9]]
    PyArrayObject has shape @[2, 5] and dtype numpy.int32
    [[ 101 102 103 104 105]
     [ 106 107 108 109 110]]

    [[ 0.  1.  2.  3.  4.]
     [ 5.  6.  7.  8.  9.]]
    PyArrayObject has shape @[2, 5] and dtype numpy.float32
    Traceback (most recent call last):
      File "test_arr1.py", line 13, in <module>
        mm.addVal(b, 101)  # Uh-oh!  ValueError will be raised here!
    ValueError: expected input array of dtype numpy.int32, received dtype numpy.float32
    Nim traceback (most recent call last):
      File "pmgen_myModule_wrap.nim", line 26, in exportpy_addVal
      File "addvalmod.nim", line 16, in addVal

Observe the `while`-loop that was used in `addVal` to iterate over the array.
This is the most flexible loop idiom for forward-iterating over an array,
since you are able to control where, and how many times, the forward iterator
will be incremented within the body of the loop:

    let bounds = arr.getBounds(int32)  # Iterator bounds
    var iter = arr.iterateForward(int32)  # Forward iterator
    while iter in bounds:
      iter[] += val
      inc(iter)  # Increment the iterator manually

However, this `while`-loop idiom is more verbose than it often needs to be.
Often, you will only need to increment the forward iterator once per iteration,
at the end of the body of the loop; if this is all you need, there is a shorter
`for`-loop idiom that you can use:

    for iter in arr.iterateForward(int32):
      iter[] += val

And if you don't need to modify the array data at all, there is an even shorter
`for`-loop idiom that yields a succession of (read-only) array values:

    var maxVal: int32 = low(int32)
    for val in arr.values(int32):
      if val > maxVal:
        maxVal = val

Likewise for `PyArrayRandomAccessIterator[T]`:

    let bounds = arr.getBounds(int32)  # Iterator bounds
    var iter = arr.accessFlat(int32)  # Random access iterator
    while iter in bounds:
      iter[] += val
      inc(iter, incDelta)  # Increment the iterator manually

and:

    for iter in arr.accessFlat(int32, incDelta):
      iter[] += val

Tips, warnings & gotchas
------------------------

Here are some helpful hints about a few sharp edges of Pymod (some of them due
to sharp edges in Nim that we haven't been able to cover over completely) that
can trip you up (and then confuse you with obscure compiler error messages):

* If you want to `exportpy` a proc using Pymod, **don't** give your proc the
  same name as the Nim module that contains the proc (or in fact, the same name
  as any other procs in that same module).
* If you want to `exportpy` a proc using Pymod, ensure that the proc is also
  [exported in Nim](http://nim-lang.org/docs/manual.html#procedures-export-marker)
  by marking it with an asterisk after the proc-name.

What about calling Python from Nim?
-----------------------------------

Pymod enables you to wrap your Nim procs so they can be called from Python.

If instead you want to call Python functions (maybe even the interpreter)
from Nim (ie, the control flows in the opposite direction), Pymod is not
what you're looking for.

In a situation like this, [python.nim](https://github.com/nim-lang/python)
or the [NimBorg project](https://github.com/micklat/NimBorg) might be what
you're looking for.

Implementation details
----------------------

We want to make existing Python types (and extended types like
[Numpy arrays](https://scipy-lectures.github.io/intro/numpy/array_object.html))
available in Nim procs.  The idea is that objects of these Python types will
be created in the existing Python code, then passed through to Nim procs for
processing, and then the results will be returned to the Python code for the
pre-existing processing or viewing in Python.

For this reason, we decided not to use the
[Python ctypes module](https://docs.python.org/2/library/ctypes.html);
the focus of `ctypes` seems to be on propagating types in the opposite
direction.  Instead of making fully-fledged Python types easily available
in C, `ctypes` wraps lowest-common-denominator C types and structs for
basic access in Python.

The way
[ctypes handles pointers](https://docs.python.org/2/library/ctypes.html#pointers)
& [structs](https://docs.python.org/2/library/ctypes.html#structures-and-unions)
requires you to build your object types up in terms of C primitive types,
so they can be accessed as method-less, field-only objects in Python.
But the Python types we want to use in Nim are already defined in Python!
So `ctypes` would be more applicable to us if we wanted to make existing
Nim data-structures available in Python, rather than the other way around.

In the future, we might investigate the use of
[CFFI](http://cffi.readthedocs.org/en/release-0.8/) &
[cffiwrap](http://cffiwrap.readthedocs.org/en/latest/).
These look (at a first, superficial glance) like they might be more
Python-type-friendly than `ctypes`.

