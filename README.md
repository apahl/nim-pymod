# Pymod

Auto-generate a [Python](http://www.python.org) module to wrap the procs in
a [Nim programming language](http://nim-lang.org) module.

The **Pymod** software package consists of Nim bindings & Python scripts to
automate the generation of
[Python C-API extension module](https://docs.python.org/2/extending/index.html)
boilerplate for Nim procs.
After Pymod has been run, there will be an auto-generated, auto-compiled
Python module that exposes the Nim procs in Python.

The auto-generated C-API boilerplate code handles the parsing & type-checking
of the function arguments passed from Python, including correct handling of
ref-counts if a type error occurs.  The boilerplate code also translates Nim exceptions
(including back-traces) to Python exceptions.  Finally, the boilerplate code provides
auto-generated Python docstrings that have been extracted from the Nim procs.

There's even a type (`ptr PyArrayObject`) that provides a Nim interface to Numpy arrays,
so you can pass Numpy arrays into your Nim procs and access them natively.

Pymod is definitely still in the **alpha** phase of software maturity, and it's
far from feature-complete, but it's been usable for our work for about 9 months now
(and we've been using it regularly during that time).  There's a lot of hacky code
in there, but it gets the job done.

Motivation
----------

Perhaps you have a large body of existing Python code, that you can't or
don't want to rewrite.  Perhaps you want to use [Numpy](http://www.numpy.org/),
[Scipy](http://www.scipy.org/) or [Matplotlib](http://www.matplotlib.org).
Perhaps your program's main loop simply must be in Python.

However, you would prefer to write Nim code and then call your Nim procs
from the Python code.  (There are many more systems written in Python than
in Nim, but it would be great to start extending them in Nim!)
You can write
[Python C-API extension modules](https://docs.python.org/2/extending/extending.html)
to wrap your Nim procs, but all the
[C-API boilerplate](https://docs.python.org/2/c-api/)
is a huge drag, especially if you check types and manage reference counts
and handle Nim exceptions properly.  That's what Pymod is for.

Usage
-----

Using Pymod is a 4-step process, preceded by an optional zeroth step:

1. At the top of your Nim source code module, import the module `pymod`.
   You might additionally wish to import `pymodpkg/docstrings` (to enable
   Python-like docstrings) and/or `pymodpkg/pyarrayobject` (to enable the
   `PyArrayObject` type that corresponds to Numpy's array type).
2. In your Nim source code module, annotate each Nim proc to be exported
   with the `{.exportpy.}` pragma (named by analogy with the standard Nim
   `{.exportc.}` pragma).
3. At the end of your Nim source code model, configure the Python module using
   the `initPyModule()` macro, specifying the desired module name as a string
   (without a filename suffix), followed by the names of the Nim procs that
   should be compiled into the Python module.
4. Invoke the supplied Python script `pmgen.py` with the filename of your
   Nim source code module as a command-line argument, to auto-generate &
   invoke a set of Makefiles that will in turn initiate & run the Pymod process.

When the script `pmgen.py` is run, it will create a subdirectory `pmgen` in
the current directory.  All the source code generated by Pymod will be placed
into this subdirectory and compiled.  At the end of the compilation process,
the new Python module, a shared object file, will be moved back into the
current directory.

The optional zeroth step is to define your own `PyObject` type (similar to how
Pymod defines the `PyArrayObject` type to represent Numpy's array type)
in Pymod's type-mapping registry, using the `definePyObjectType()` macro.
This provides Pymod with a mapping from an already-defined Nim type to the
corresponding Python & C-API types, enabling Pymod to generate the type-checking
boilerplate for additional non-core-Python types.

Example
-------

Here's a short "Hello world" example (assumed to be in a file called `greeting.nim`):

    ## Compile this Nim module using the following command:
    ##   python path/to/pmgen.py greeting.nim

    import strutils  # `%` operator

    import pymod
    import pymodpkg/docstrings

    proc greet*(audience: string): string {.exportpy.} =
      docstring"""Greet the specified audience with a familiar greeting.

      The string returned will be a greeting directed specifically at that audience.
      """
      return "Hello, $1!" % audience

    initPyModule("hw", greet)

Use the Python script `pmgen.py` to auto-generate & compile the boilerplate code:

    python path/to/pmgen.py greeting.nim

There will now be a compiled Python extension module `hw.so` in the current directory.
(It is called `hw` because is the name that was specified in the `initPyModule()` macro).

In a Python interpreter, you can import the module and invoke the `greet` function:

    >>> import hw
    >>> hw.greet
    <built-in function greet>
    >>> hw.greet("World")
    'Hello, World!'
    >>>

You can also invoke the built-in Python interpreter `help` function about the `greet` function:

    >>> help(hw.greet)
    Help on built-in function greet in module hw:

    greet(...)
        greet(audience: str) -> (str)

        Parameters
        ----------
        audience : str -> string

        Returns
        -------
        out : (str) <- (string)

        Greet the specified audience with a familiar greeting.

        The string returned will be a greeting directed specifically at that audience.

There is additional example code in the `tests` directory.

Docstrings
----------

Pymod will also auto-generate a Python docstring for each function in the
extension module, specifying the function's parameter types & return type,
based upon the parameter types & return types of the exported Nim proc.
You can embed additional documentation in each Nim proc you want to export,
using the supplied `docstring"""Text goes here."""` string type.  Any docstrings
in the proc will be extracted automatically and included in the generated Python
docstring.  There is an example of docstring usage in the code sample above.

Function parameter & return types
---------------------------------

Default parameters are supported to a limited extent, although the parameter
types must be specified explicitly, and are currently restricted to `string`,
`int` & `float` types.

Procedure return values may be basic types (`int`, `float64`, `string`, `ptr X`)
or a Nim tuple of those types.  Nested tuples are currently not supported.
By default, named tuples in Nim are returned as raw tuples to Python:

    # Nim                   # Python
    tuple[ a, b: int ]  =>  (a_value, b_value)

If `exportpy` is specified as `exportpy return_dict` then the generated
code will instead return a Python dict containing the named properties:

    # Nim                   # Python
    tuple[ a, b: int ]  =>  { "a": a_value, "b": b_value }

Per-project configuration
-------------------------

If there is a file `pymod.cfg` in the same directory as the Nim module you want
to wrap, Pymod will read this as a configuration file for that project.

By default, Pymod runs the Nim compiler in **non-release** mode, and additionally
performs per-dereference bounds-checking of the `PyArrayObject` iterators.
This is safe (and catches all sorts of pesky bugs!) but slow.

If the file `pymod.cfg` in the current directory contains the following directives:

    [all]
    nimSetIsRelease: true

then the Nim compiler will be invoked in **release mode**, and bounds-checking
of the `PyArrayObject` iterators will be switched off.  Your code will now run
much faster!

System requirements
-------------------

* The [latest Nim compiler from Github](http://nim-lang.org/download.html#installation-from-github)
  * either the `stable` or `devel` branches
  * but **not the recent [Nim 0.12.0 release](http://nim-lang.org/news.html#Z2015-10-27-version-0-12-0-released)**. :(
* CPython 2.7 or CPython 3.2+
* Python C development header files & static library
* [Numpy](http://www.numpy.org)
* Numpy C development header files
* A C compiler [for use by Nim](http://nim-lang.org/download.html)

What about calling Python from Nim?
-----------------------------------

Pymod enables you to wrap your Nim procs so they can be called from Python.

If instead you want to call Python functions (maybe even the interpreter)
from Nim (ie, the control flows in the opposite direction), Pymod is not
what you're looking for.

In a situation like this, [python.nim](https://github.com/nim-lang/python)
or the [NimBorg project](https://github.com/micklat/NimBorg) might be what
you're looking for.

Implementation details
----------------------

We want to make existing Python types (and extended types like
[Numpy arrays](https://scipy-lectures.github.io/intro/numpy/array_object.html))
available in Nim procs.  The idea is that objects of these Python types will
be created in the existing Python code, then passed through to Nim procs for
processing, and then the results will be returned to the Python code for the
pre-existing processing or viewing in Python.

For this reason, we decided not to use the
[Python ctypes module](https://docs.python.org/2/library/ctypes.html);
the focus of `ctypes` seems to be on propagating types in the opposite
direction.  Instead of making fully-fledged Python types easily available
in C, `ctypes` wraps lowest-common-denominator C types and structs for
basic access in Python.

The way
[ctypes handles pointers](https://docs.python.org/2/library/ctypes.html#pointers)
& [structs](https://docs.python.org/2/library/ctypes.html#structures-and-unions)
requires you to build your object types up in terms of C primitive types,
so they can be accessed as method-less, field-only objects in Python.
But the Python types we want to use in Nim are already defined in Python!
So `ctypes` would be more applicable to us if we wanted to make existing
Nim data-structures available in Python, rather than the other way around.

In the future, we might investigate the use of
[CFFI](http://cffi.readthedocs.org/en/release-0.8/) &
[cffiwrap](http://cffiwrap.readthedocs.org/en/latest/).
These look (at a first, superficial glance) like they might be more
Python-type-friendly than `ctypes`.

